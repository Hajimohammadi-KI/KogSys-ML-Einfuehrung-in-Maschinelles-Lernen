# Copilot Instructions
- Repository structure: assignments are separated by folder; each contains its own notebook(s) and assets. No top-level app or tests. Most work happens inside the student notebooks.
- Python version: >=3.9 (see KogSysMLP pyproject). Install per-assignment dependencies from the assignment folder so relative paths resolve (e.g., run `%pip install -U -r requirements.txt` in the notebook or `pip install -U -r requirements.txt` from the folder).
- Assignment 3 DL setup: notebooks expect the requirements in [Assignments/Assignment-3 - ws - 2526/requirements.txt](Assignments/Assignment-3%20-%20ws%20-%202526/requirements.txt). The notebook [Assignments/Assignment-3 - ws - 2526/student_version_en.ipynb](Assignments/Assignment-3%20-%20ws%20-%202526/student_version_en.ipynb) installs via `%pip` in the first code cell; keep the working directory at the assignment root so images/ paths work.
- Assignment 1 data: dataset is shipped as [Assignments/Assignment -1- ws - 2526/assignment-1-ws-2526/mushrooms.csv](Assignments/Assignment%20-1-%20ws%20-%202526/assignment-1-ws-2526/mushrooms.csv). Use relative paths from the assignment folder when loading.
- Assignment 2 codebase: core classes live in [Assignments/Assignment -2  ws - 2526/Assignment-2/KogSysMLP/Perceptron.py](Assignments/Assignment%20-2%20%20ws%20-%202526/Assignment-2/KogSysMLP/Perceptron.py) and [Assignments/Assignment -2  ws - 2526/Assignment-2/KogSysMLP/MLP.py](Assignments/Assignment%20-2%20%20ws%20-%202526/Assignment-2/KogSysMLP/MLP.py).
- Perceptron implementation: sigmoid unit with manual gradient update in `fit` (per-sample loop). Weight init uses `np.random.randn`; `resume=True` skips re-init. `predict` thresholds at 0.5.
- MLP implementation: builds layers from Perceptron instances and caches matrix views via `update_matrices` for faster forward passes. Uses sigmoid activation everywhere; `forward` does pure feedforward; `predict` maps argmax to stored class labels. `backprop` and `fit` are `NotImplemented` placeholders intended for student solutionsâ€”preserve existing signatures and numpy-first style when filling in.
- Data handling in MLP: `__one_hot` expects labels convertible to numpy arrays; `__init_layers` infers input dimension from `X` and classes from `y`, constructs hidden layers from `hidden_layers` plus output layer sized to number of classes.
- Notebook conventions: tasks are marked with markdown instructions and often rely on code cells pre-populated with scaffolding; keep outputs reproducible and avoid renaming provided variable names. Submission metadata and bonus-point rules are in the opening markdown cells of each notebook.
- Paths contain spaces; quote them in shell commands (`"Assignments/Assignment -2  ws - 2526/Assignment-2"`). Avoid moving notebooks or datasets; relative references would break.
- No automated tests or CI are present. Validate changes by rerunning the corresponding notebook sections. Prefer lightweight numpy/scikit-learn debugging rather than introducing new frameworks.
- License: KogSysMLP package declares GPL-3.0 (pyproject). Preserve headers and existing imports.
- If adding new helpers, keep them local to the assignment folder (avoid new top-level packages) and match the teaching style: simple procedural cells or small classes, minimal dependencies beyond the provided requirements.
